{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "App.svelte",
    "Countdown.svelte",
    "InGame.svelte",
    "MainMenu.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">import MainMenu from \"./MainMenu.svelte\";\nimport InGame from \"./InGame.svelte\";\nimport PostGame from \"./PostGame.svelte\";\n;\nimport { chapterPlayed, playerName } from \"../stores\";\nimport { reportResult } from \"../spreadsheetApi\";\nlet gameStage = \"MAIN-MENU\";\nlet selectedQuestions;\nlet gameResult;\nconst startGame = ({ detail }) => {\n    selectedQuestions = detail.questionSet;\n    gameStage = \"IN-GAME\";\n};\nconst endGame = ({ detail }) => {\n    gameResult = detail;\n    gameStage = \"POST-GAME\";\n    reportResult({\n        playerName: $playerName,\n        chapterPlayed: $chapterPlayed,\n        ...detail,\n    });\n};\n</script>\n\n<main>\n  {#if gameStage === \"IN-GAME\"}\n    <InGame {selectedQuestions} on:endGame={endGame} />\n  {:else if gameStage === \"POST-GAME\"}\n    <PostGame {gameResult} on:playAgain={() => (gameStage = \"MAIN-MENU\")} />\n  {:else}\n    <MainMenu on:startGame={startGame} />\n  {/if}\n</main>\n\n<style>\n  main {\n    text-align: center;\n    padding: 1em;\n    max-width: 240px;\n    margin: 0 auto;\n  }\n\n  h1 {\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 4em;\n    font-weight: 100;\n  }\n\n  @media (min-width: 640px) {\n    main {\n      max-width: none;\n    }\n  }\n</style>\n",
    "<script lang=\"ts\">import { createEventDispatcher, onMount } from \"svelte\";\nconst dispatch = createEventDispatcher();\nexport let value;\nexport let tickMillis = 1000;\nexport let blinkAt = 5;\nexport let stopAt = 1;\nexport const reset = (newValue) => {\n    clearInterval(interval);\n    value = newValue;\n    interval = setInterval(tick, tickMillis);\n};\nconst tick = () => {\n    if (value === stopAt)\n        return dispatch(\"expire\");\n    value -= 1;\n};\n// TODO: Why does it carry over the ticking interval when the component is rerendered?\nlet interval;\nonMount(() => {\n    interval = setInterval(tick, tickMillis);\n    return () => clearInterval(interval);\n});\n</script>\n\n<style>\n  .blinking {\n    color: red;\n    animation: blinker 0.75s linear infinite;\n  }\n  @keyframes blinker {\n    50% {\n      opacity: 0;\n    }\n  }\n</style>\n\n<h3 class={value > blinkAt ? '' : 'blinking'}>{value}</h3>\n",
    "<script lang=\"ts\">;\nimport { createEventDispatcher } from \"svelte\";\nimport { timeToSelectAnswer } from \"../gameSettings\";\nimport Countdown from \"./Countdown.svelte\";\nimport { randomElement, shuffle } from \"../util\";\nconst dispatch = createEventDispatcher();\nexport let selectedQuestions;\nlet currentQuestionNumber = 1;\nlet score = 0;\nlet timer, currentQuestion, answerChoices;\n$: currentQuestion = selectedQuestions[currentQuestionNumber - 1];\n$: answerChoices = shuffle([\n    ...currentQuestion.incorrectOptions,\n    currentQuestion.correctAnswer,\n]);\nconst handleChoice = (e) => {\n    if (currentQuestion.correctAnswer === e.target.textContent)\n        score += 1;\n    // return endGame(Outcomes.INCORRECT_ANSWER);\n    if (currentQuestionNumber === selectedQuestions.length)\n        return endGame(Outcomes.WIN);\n    currentQuestionNumber += 1;\n    timer.reset(timeToSelectAnswer);\n};\nconst helpOptions = {\n    fiftyFifty: {\n        displayName: \"50/50\",\n        handler() {\n            currentQuestion.incorrectOptions = [\n                randomElement(currentQuestion.incorrectOptions),\n            ];\n            helpOptions.fiftyFifty.available = false;\n        },\n        available: true,\n    },\n};\nvar Outcomes;\n(function (Outcomes) {\n    Outcomes[Outcomes[\"WIN\"] = 0] = \"WIN\";\n    Outcomes[Outcomes[\"INCORRECT_ANSWER\"] = 1] = \"INCORRECT_ANSWER\";\n    Outcomes[Outcomes[\"TIME_EXPIRED\"] = 2] = \"TIME_EXPIRED\";\n})(Outcomes || (Outcomes = {}));\nconst endGame = (outcome) => {\n    dispatch(\"endGame\", { score, gameLength: selectedQuestions.length });\n};\n</script>\n\n<div>\n  <p class=\"withColor\">\n    Вопрос #{currentQuestionNumber} из {selectedQuestions.length}\n  </p>\n  <p>{currentQuestion.questionText}</p>\n  {#each answerChoices as choice}\n    <ul>\n      <button on:click={handleChoice}>{choice}</button>\n    </ul>\n  {/each}\n  <Countdown\n    value={timeToSelectAnswer}\n    bind:this={timer}\n    on:expire={() => endGame(Outcomes.TIME_EXPIRED)}\n  />\n  <hr />\n  {#each Object.entries(helpOptions) as [key, { available, handler, displayName }]}\n    <button on:click={handler} disabled={!available} id={key}\n      >{displayName}</button\n    >\n  {/each}\n</div>\n\n<style>\n  p.withColor {\n    color: orange;\n    flex-wrap: wrap;\n  }\n  p {\n    font-size: 20px;\n    margin-block-start: 0px;\n  }\n  div {\n    flex-wrap: wrap;\n    max-width: 240px;\n    margin: 0 auto;\n    text-align: center;\n  }\n  ul {\n    padding-inline-start: 0px;\n    margin-block-end: 0px;\n    margin-block-start: 0px;\n  }\n  button {\n    width: 240px;\n    font-size: 16px;\n  }\n</style>\n",
    "<script lang=\"ts\">import { chapterPlayed, playerName } from \"../stores\";\nimport { createEventDispatcher, onMount } from \"svelte\";\nimport { fetchQuestions } from \"../spreadsheetApi\";\nconst dispatch = createEventDispatcher();\nconst questionSetNames = [\n    \"1 глава\",\n    \"2 глава\",\n    \"3 глава\",\n    \"4 глава\",\n    \"5 глава\",\n    \"6 глава\",\n    \"7 глава\",\n    \"8 глава\",\n    \"9 глава\",\n    \"10 глава\",\n    \"11 глава\",\n    \"12 глава\",\n    \"13 глава\",\n    \"14 глава\",\n    \"15 глава\",\n    \"16 глава\",\n    \"17 глава\",\n    \"18 глава\",\n];\nconst startGame = async (e) => {\n    const questionSet = await fetchQuestions(e.target.textContent);\n    $chapterPlayed = e.target.textContent;\n    dispatch(\"startGame\", {\n        questionSet,\n    });\n};\nlet playerNameInput;\nonMount(() => {\n    if ($playerName.length === 0) {\n        playerNameInput.focus();\n    }\n});\n</script>\n\n<input\n  type=\"text\"\n  name=\"playerName\"\n  placeholder=\"Ваше Имя\"\n  bind:value={$playerName}\n  bind:this={playerNameInput}\n/>\n\n<br />\n<div>\n  {#each questionSetNames as name}\n    <button on:click={startGame} disabled={$playerName.length === 0}\n      >{name}</button\n    >\n  {/each}\n</div>\n\n<style>\n  div {\n    flex-wrap: wrap;\n    max-width: 240px;\n    margin: 0 auto;\n    text-align: center;\n  }\n  button {\n    width: 100px;\n    margin-right: 16px;\n    margin-top: 12px;\n  }\n  input {\n    width: 220px;\n    margin-right: 16px;\n  }\n</style>\n"
  ],
  "names": [],
  "mappings": "AAmCE,IAAI,eAAC,CAAC,AACJ,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CACZ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,AAChB,CAAC,AASD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,IAAI,eAAC,CAAC,AACJ,SAAS,CAAE,IAAI,AACjB,CAAC,AACH,CAAC;AC5BD,SAAS,eAAC,CAAC,AACT,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,sBAAO,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,AAC1C,CAAC,AACD,WAAW,sBAAQ,CAAC,AAClB,GAAG,AAAC,CAAC,AACH,OAAO,CAAE,CAAC,AACZ,CAAC,AACH,CAAC;ACsCD,CAAC,UAAU,cAAC,CAAC,AACX,KAAK,CAAE,MAAM,CACb,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,CAAC,cAAC,CAAC,AACD,SAAS,CAAE,IAAI,CACf,kBAAkB,CAAE,GAAG,AACzB,CAAC,AACD,GAAG,cAAC,CAAC,AACH,SAAS,CAAE,IAAI,CACf,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,UAAU,CAAE,MAAM,AACpB,CAAC,AACD,EAAE,cAAC,CAAC,AACF,oBAAoB,CAAE,GAAG,CACzB,gBAAgB,CAAE,GAAG,CACrB,kBAAkB,CAAE,GAAG,AACzB,CAAC,AACD,MAAM,cAAC,CAAC,AACN,KAAK,CAAE,KAAK,CACZ,SAAS,CAAE,IAAI,AACjB,CAAC;ACpCD,GAAG,eAAC,CAAC,AACH,SAAS,CAAE,IAAI,CACf,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,UAAU,CAAE,MAAM,AACpB,CAAC,AACD,MAAM,eAAC,CAAC,AACN,KAAK,CAAE,KAAK,CACZ,YAAY,CAAE,IAAI,CAClB,UAAU,CAAE,IAAI,AAClB,CAAC,AACD,KAAK,eAAC,CAAC,AACL,KAAK,CAAE,KAAK,CACZ,YAAY,CAAE,IAAI,AACpB,CAAC"
}