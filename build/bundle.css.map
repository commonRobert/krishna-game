{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "App.svelte",
    "Countdown.svelte",
    "InGame.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">import MainMenu from \"./MainMenu.svelte\";\r\nimport InGame from \"./InGame.svelte\";\r\nimport PostGame from \"./PostGame.svelte\";\r\n;\r\nlet gameStage = \"MAIN-MENU\";\r\nlet selectedQuestions;\r\nlet gameResult;\r\nconst startGame = ({ detail }) => {\r\n    selectedQuestions = detail.questionSet;\r\n    gameStage = \"IN-GAME\";\r\n};\r\nconst endGame = ({ detail }) => {\r\n    gameResult = detail;\r\n    gameStage = \"POST-GAME\";\r\n};\r\n</script>\r\n\r\n<main>\r\n  {#if gameStage === \"IN-GAME\"}\r\n    <InGame {selectedQuestions} on:endGame={endGame} />\r\n  {:else if gameStage === \"POST-GAME\"}\r\n    <PostGame {gameResult} on:playAgain={() => (gameStage = \"MAIN-MENU\")} />\r\n  {:else}\r\n    <MainMenu on:startGame={startGame} />\r\n  {/if}\r\n</main>\r\n\r\n<style>\r\n  main {\r\n    text-align: center;\r\n    padding: 1em;\r\n    max-width: 240px;\r\n    margin: 0 auto;\r\n  }\r\n\r\n  h1 {\r\n    color: #ff3e00;\r\n    text-transform: uppercase;\r\n    font-size: 4em;\r\n    font-weight: 100;\r\n  }\r\n\r\n  @media (min-width: 640px) {\r\n    main {\r\n      max-width: none;\r\n    }\r\n  }\r\n</style>\r\n",
    "<script lang=\"ts\">import { createEventDispatcher, onMount } from \"svelte\";\r\nconst dispatch = createEventDispatcher();\r\nexport let value;\r\nexport let tickMillis = 1000;\r\nexport let blinkAt = 5;\r\nexport let stopAt = 1;\r\nexport const reset = (newValue) => {\r\n    clearInterval(interval);\r\n    value = newValue;\r\n    interval = setInterval(tick, tickMillis);\r\n};\r\nconst tick = () => {\r\n    if (value === stopAt)\r\n        return dispatch(\"expire\");\r\n    value -= 1;\r\n};\r\n// TODO: Why does it carry over the ticking interval when the component is rerendered?\r\nlet interval;\r\nonMount(() => {\r\n    interval = setInterval(tick, tickMillis);\r\n    return () => clearInterval(interval);\r\n});\r\n</script>\r\n\r\n<style>\r\n  .blinking {\r\n    color: red;\r\n    animation: blinker 0.75s linear infinite;\r\n  }\r\n  @keyframes blinker {\r\n    50% {\r\n      opacity: 0;\r\n    }\r\n  }\r\n</style>\r\n\r\n<h3 class={value > blinkAt ? '' : 'blinking'}>{value}</h3>\r\n",
    "<script lang=\"ts\">;\r\nimport { createEventDispatcher } from \"svelte\";\r\nimport { timeToSelectAnswer } from \"../gameSettings\";\r\nimport Countdown from \"./Countdown.svelte\";\r\nimport { randomElement, shuffle } from \"../util\";\r\nconst dispatch = createEventDispatcher();\r\nexport let selectedQuestions;\r\nlet currentQuestionNumber = 1;\r\nlet score = 0;\r\nlet timer, currentQuestion, answerChoices;\r\n$: currentQuestion = selectedQuestions[currentQuestionNumber - 1];\r\n$: answerChoices = shuffle([\r\n    ...currentQuestion.incorrectOptions,\r\n    currentQuestion.correctAnswer,\r\n]);\r\nconst handleChoice = (e) => {\r\n    if (currentQuestion.correctAnswer === e.target.textContent)\r\n        score += 1;\r\n    // return endGame(Outcomes.INCORRECT_ANSWER);\r\n    if (currentQuestionNumber === selectedQuestions.length)\r\n        return endGame(Outcomes.WIN);\r\n    currentQuestionNumber += 1;\r\n    timer.reset(timeToSelectAnswer);\r\n};\r\nconst helpOptions = {\r\n    fiftyFifty: {\r\n        displayName: \"50/50\",\r\n        handler() {\r\n            currentQuestion.incorrectOptions = [\r\n                randomElement(currentQuestion.incorrectOptions),\r\n            ];\r\n            helpOptions.fiftyFifty.available = false;\r\n        },\r\n        available: true,\r\n    },\r\n};\r\nvar Outcomes;\r\n(function (Outcomes) {\r\n    Outcomes[Outcomes[\"WIN\"] = 0] = \"WIN\";\r\n    Outcomes[Outcomes[\"INCORRECT_ANSWER\"] = 1] = \"INCORRECT_ANSWER\";\r\n    Outcomes[Outcomes[\"TIME_EXPIRED\"] = 2] = \"TIME_EXPIRED\";\r\n})(Outcomes || (Outcomes = {}));\r\nconst endGame = (outcome) => {\r\n    let details;\r\n    switch (outcome) {\r\n        case Outcomes.WIN:\r\n            details = { win: true,\r\n                score: score,\r\n                gameLength: selectedQuestions.length };\r\n            break;\r\n        // case Outcomes.INCORRECT_ANSWER:\r\n        //   details = {\r\n        //     win: false,\r\n        //     failedQuestion: currentQuestion,\r\n        //     questionNumber: currentQuestionNumber,\r\n        //   };\r\n        //   break;\r\n        case Outcomes.TIME_EXPIRED:\r\n            details = {\r\n                win: false,\r\n                failedQuestion: currentQuestion,\r\n                questionNumber: currentQuestionNumber,\r\n            };\r\n            break;\r\n    }\r\n    dispatch(\"endGame\", details);\r\n};\r\n</script>\r\n\r\n<style>\r\n  pre {\r\n    color: orange;\r\n  }\r\n</style>\r\n\r\n<div>\r\n  <pre>Вопрос #{currentQuestionNumber}</pre>\r\n  <pre>{currentQuestion.questionText}</pre>\r\n  {#each answerChoices as choice}\r\n    <button on:click={handleChoice}>{choice}</button>\r\n  {/each}\r\n  <Countdown\r\n    value={timeToSelectAnswer}\r\n    bind:this={timer}\r\n    on:expire={() => endGame(Outcomes.TIME_EXPIRED)} />\r\n  <hr />\r\n  {#each Object.entries(helpOptions) as [key, { available, handler, displayName }]}\r\n    <button\r\n      on:click={handler}\r\n      disabled={!available}\r\n      id={key}>{displayName}</button>\r\n  {/each}\r\n</div>\r\n"
  ],
  "names": [],
  "mappings": "AA4BE,IAAI,eAAC,CAAC,AACJ,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CACZ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,AAChB,CAAC,AASD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,IAAI,eAAC,CAAC,AACJ,SAAS,CAAE,IAAI,AACjB,CAAC,AACH,CAAC;ACrBD,SAAS,eAAC,CAAC,AACT,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,sBAAO,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,AAC1C,CAAC,AACD,WAAW,sBAAQ,CAAC,AAClB,GAAG,AAAC,CAAC,AACH,OAAO,CAAE,CAAC,AACZ,CAAC,AACH,CAAC;ACqCD,GAAG,eAAC,CAAC,AACH,KAAK,CAAE,MAAM,AACf,CAAC"
}